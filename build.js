// ============================================
// VERCEL BUILD SCRIPT - SECURE VERSION
// Injects environment variables into JavaScript (NOT HTML meta tags)
// ============================================

const fs = require('fs');
const path = require('path');

// Environment variables to inject (from Vercel)
const envVars = {
  // Firebase Configuration
  'NEXT_PUBLIC_FIREBASE_API_KEY': process.env.NEXT_PUBLIC_FIREBASE_API_KEY || '',
  'NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN': process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN || '',
  'NEXT_PUBLIC_FIREBASE_PROJECT_ID': process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || '',
  'NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET': process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET || '',
  'NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID': process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID || '',
  'NEXT_PUBLIC_FIREBASE_APP_ID': process.env.NEXT_PUBLIC_FIREBASE_APP_ID || '',
  'NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID': process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID || '',

  // Default Owner Account
  'NEXT_PUBLIC_DEFAULT_OWNER_EMAIL': process.env.NEXT_PUBLIC_DEFAULT_OWNER_EMAIL || '',
  'NEXT_PUBLIC_DEFAULT_OWNER_NAME': process.env.NEXT_PUBLIC_DEFAULT_OWNER_NAME || '',
  'NEXT_PUBLIC_DEFAULT_OWNER_PASSWORD': process.env.NEXT_PUBLIC_DEFAULT_OWNER_PASSWORD || '',

  // Security Settings
  'NEXT_PUBLIC_PBKDF2_ITERATIONS': process.env.NEXT_PUBLIC_PBKDF2_ITERATIONS || '310000',
  'NEXT_PUBLIC_PASSWORD_SALT': process.env.NEXT_PUBLIC_PASSWORD_SALT || '',
  'NEXT_PUBLIC_FIREBASE_SYNC': process.env.NEXT_PUBLIC_FIREBASE_SYNC || 'true'
};

console.log('[Build] Starting secure build process...');

// ============================================
// ðŸ”’ ENCRYPTION FUNCTION - Hide values from source
// ============================================
function obfuscateValue(value) {
  if (!value || value.length === 0) return '';

  // Simple XOR obfuscation (hides from casual viewing)
  const key = 'AHMEDTECH_DZ_2026';
  let result = '';
  for (let i = 0; i < value.length; i++) {
    result += String.fromCharCode(value.charCodeAt(i) ^ key.charCodeAt(i % key.length));
  }
  return btoa(result); // Base64 encode
}

function generateEnvScript() {
  const obfuscatedVars = {};

  for (const [key, value] of Object.entries(envVars)) {
    if (value && value.length > 0 && !value.includes('%')) {
      obfuscatedVars[key] = obfuscateValue(value);
    } else {
      obfuscatedVars[key] = '';
    }
  }

  return `
// ============================================
// Environment Variables - Auto-generated by build.js
// DO NOT EDIT - This file is generated during build
// ============================================

(function() {
  'use strict';

  // Deobfuscation function
  function deobfuscate(encoded) {
    if (!encoded) return '';
    const key = 'AHMEDTECH_DZ_2026';
    const decoded = atob(encoded);
    let result = '';
    for (let i = 0; i < decoded.length; i++) {
      result += String.fromCharCode(decoded.charCodeAt(i) ^ key.charCodeAt(i % key.length));
    }
    return result;
  }

  // Environment variables (obfuscated)
  const obfuscatedEnv = ${JSON.stringify(obfuscatedVars, null, 2)};

  // Create ENV object
  window.ENV = window.ENV || {};
  window.process = window.process || {};
  window.process.env = window.process.env || {};

  // Deobfuscate and expose
  for (const [key, value] of Object.entries(obfuscatedEnv)) {
    const deobfuscated = deobfuscate(value);
    window.ENV[key] = deobfuscated;
    window.process.env[key] = deobfuscated;
  }

  // Helper function
  window.getEnv = function(key, defaultValue) {
    return window.ENV[key] || window.process.env[key] || defaultValue;
  };

  // Signal that env is loaded
  window.ENV_LOADED = true;
  window.dispatchEvent(new CustomEvent('env-loaded'));

  console.log('[Env] Environment variables loaded securely');
})();
`;
}

// Create dist directory
const distDir = path.join(__dirname, 'dist');
if (!fs.existsSync(distDir)) {
  fs.mkdirSync(distDir, { recursive: true });
}

// Read source HTML
const sourceHtmlPath = path.join(__dirname, 'index.html');
if (!fs.existsSync(sourceHtmlPath)) {
  console.error('[Build] âŒ Error: index.html not found!');
  process.exit(1);
}

let htmlContent = fs.readFileSync(sourceHtmlPath, 'utf8');

// Replace the env-script placeholder with actual obfuscated script
const envScript = generateEnvScript();
const placeholder = '<script id="env-script">\s*// This will be replaced.*?window\.__ENV__ = "INJECTED_BY_BUILD";\s*</script>';
htmlContent = htmlContent.replace(new RegExp(placeholder, 's'), `<script id="env-script">${envScript}</script>`);

// Write processed HTML to dist
const outputHtmlPath = path.join(distDir, 'index.html');
fs.writeFileSync(outputHtmlPath, htmlContent);
console.log('[Build] âœ… Written dist/index.html with obfuscated env vars');

// Copy other static files to dist
const filesToCopy = [
  'style.css',
  'config.js',
  'script.js',
  'inject-env.js'
];

filesToCopy.forEach(file => {
  const srcPath = path.join(__dirname, file);
  const destPath = path.join(distDir, file);

  if (fs.existsSync(srcPath)) {
    fs.copyFileSync(srcPath, destPath);
    console.log(`[Build] âœ… Copied ${file}`);
  } else {
    console.warn(`[Build] âš ï¸ Warning: ${file} not found, skipping`);
  }
});

// Copy static directories
function copyDirectorySync(src, dest) {
  if (!fs.existsSync(dest)) {
    fs.mkdirSync(dest, { recursive: true });
  }

  const entries = fs.readdirSync(src, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    if (entry.isDirectory()) {
      copyDirectorySync(srcPath, destPath);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}

const staticDirs = [
  'images', 'img', 'assets', 'fonts', 'uploads', 
  'css', 'js', 'media', 'icons', 'data'
];

staticDirs.forEach(dirName => {
  const srcDir = path.join(__dirname, dirName);
  const distDestDir = path.join(distDir, dirName);

  if (fs.existsSync(srcDir)) {
    copyDirectorySync(srcDir, distDestDir);
    console.log(`[Build] âœ… Copied directory: ${dirName}`);
  }
});

// Copy image files in root
const filesInRoot = fs.readdirSync(__dirname);
const imageFiles = filesInRoot.filter(file => {
  const ext = path.extname(file).toLowerCase();
  return ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp', '.ico', '.bmp', '.tiff'].includes(ext);
});

imageFiles.forEach(file => {
  const srcPath = path.join(__dirname, file);
  const destPath = path.join(distDir, file);

  if (fs.statSync(srcPath).isFile()) {
    fs.copyFileSync(srcPath, destPath);
    console.log(`[Build] ðŸ–¼ï¸ Copied image: ${file}`);
  }
});

// Create .vercel/output/static structure
const vercelOutputDir = path.join(__dirname, '.vercel', 'output', 'static');
if (!fs.existsSync(vercelOutputDir)) {
  fs.mkdirSync(vercelOutputDir, { recursive: true });
}

// Copy all dist files to .vercel/output/static
const distFiles = fs.readdirSync(distDir);
distFiles.forEach(file => {
  const srcPath = path.join(distDir, file);
  const destPath = path.join(vercelOutputDir, file);

  const stat = fs.statSync(srcPath);
  if (stat.isDirectory()) {
    copyDirectorySync(srcPath, destPath);
  } else {
    fs.copyFileSync(srcPath, destPath);
  }
});

console.log('[Build] âœ… Copied files to .vercel/output/static');

// Create config.json for Vercel Build Output API
const configJson = {
  version: 3,
  routes: [
    {
      src: '/(.*)',
      dest: '/$1'
    }
  ]
};

fs.writeFileSync(
  path.join(__dirname, '.vercel', 'output', 'config.json'),
  JSON.stringify(configJson, null, 2)
);

console.log('[Build] âœ… Created .vercel/output/config.json');
console.log('[Build] âœ… Build completed successfully!');
console.log('[Build] ðŸ”’ Environment variables are obfuscated in source');
